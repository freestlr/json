#!/usr/bin/env node

var util = require('util')
var fs   = require('fs')
var vm   = require('vm')

var opt = {
	depth  : null,
	colors : process.stdout.isTTY
}
var pre = {
	armap  : '_abcdefghijklmnopqrstuvw'.split(''),
	binary : null,
	sleep  : 0,
	input  : '',
	names  : [],
	exec   : [],
	raw    : [],
	files  : []
}
var run = {
	context: {},
	scripts: [],
	objects: []
}

// node ~/bin/json ...
for(var i = 1; i < process.argv.length; i++) {
	var a = process.argv[i]

	if(i === 1) {
		pre.binary = a
	} else if(/^-[a-zA-Z]+$/.test(a)) { // -oPts
		argv_read_shortarg(a, i)
	} else {
		argv_read_filename(a, i)
	}
}

function warn(text) {
	opt.verbose && process.stderr.write(text +'\n')
}

function usage() {
	return ['Usage: '+ pre.binary +' [OPTIONS]* [FILE]*',
		'',
		'	FILE      interpret FILE as json, if no luck - split to array of strings',
		'	          each FILE gets its own variable "[a-z]" in order of appearance',
		'	          stdin gets variable "_"',
		'	-e FILE   execute js FILE within current context',
		'	-r FILE   raw, don\'t parse file in any way',
		'',
		'	-h   show this help',
		'	-s   stringify output',
		'	-f   format output',
		'	-w   write output to first FILE specified ("a" FILE)',
		'	-d   dump inline scripts and script FILEs given by -e',
		'	-u   unwrap output string from "quotes"',
		'	-v   verbose, show some process messages',
		'	-n   don\'t add newline at end of output',
		'	-N   disable inline script substitutions:',
		'	     "#{" -> "function(x,y,z) {"',
		'	     "@"  -> "return "',
		'	-d   each -d increases inspection depth by 1, default null',
		'	-c   invert colorize output, by default colors enabled for TTY',
		''
	].join('\n')
}

function argv_read_shortarg(batch, index) {
	var arg, args = batch.slice(1).split('')

	while(arg = args.pop()) switch(arg) {
		case 'h': opt.usage   = true       ;break
		case 's': opt.string  = true       ;break
		case 'f': opt.format  = true       ;break
		case 'w': opt.write   = true       ;break
		case 'd': opt.dump    = true       ;break
		case 'u': opt.unwrap  = true       ;break
		case 'v': opt.verbose = true       ;break
		case 'n': opt.noeofnl = true       ;break
		case 'N': opt.nosubst = true       ;break
		case 'z': opt.depth++              ;break
		case 'c': opt.colors = !opt.colors ;break
		case 'e': pre.exec[index + 1] = 1  ;break
		case 'r': pre.raw [index + 1] = 1  ;break

		default:
			warn('Unrecognised option: -'+ o)
	}
}

function argv_read_filename(name, index) {
	pre.sleep++

	fs.stat(name, function(err, stat) {
		if(err || !(stat.isFile() || stat.isFIFO())) return check_n_go()

		fs.readFile(name, function(err, data) {
			if(err) {
				warn('Error reading file "'+ name +'": '+ err)
			} else {
				pre.names[index] = name
				pre.files[index] = data +''
			}
			check_n_go()
		})
	})
}

if(!process.stdin.isTTY) {
	pre.sleep++

	process.stdin.on('readable', function() {
		pre.input += process.stdin.read() || ''
	})

	process.stdin.on('end', check_n_go)
}

function check_n_go() {
	--pre.sleep || go()
}

if(opt.usage || !pre.sleep) {
	process.stderr.write(usage())
	process.exit(1)
}

function go() {
	run.objects.push({
		name: ':stdin:',
		data: pre.input
	})

	for(var i = 0; i < process.argv.length; i++) {
		var argi = process.argv[i]
		,   name = pre.names[i]
		,   data = pre.files[i]

		if(i >= 2 && !/^-[a-zA-Z]+$/.test(argi) && !name) {
			name = 'commandline #'+ i
			if(opt.nosubst) data = argi
			else data = argi
				.replace(/#{/g, 'function(x,y,z) {')
				.replace(/@/g, 'return ')
			pre.exec[i] = 1
		}

		if(pre.exec[i]) {
			run.scripts.push({
				name: name,
				source: data,
				output: undefined,
				func: new vm.Script(data, { filename: name })
			})

		} else if(name) {

			if(run.objects.length < 23) {
				run.objects.push({
					name: name,
					raw : pre.raw[i],
					data: data
				})
			} else {
				warn('Too many files given, "'+ name +'" dropped')
			}
		}
	}

	for(var i = 0; i < run.objects.length; i++) {
		var file = run.objects[i]
		file.argument = pre.armap[i]

		if(file.raw) {
			file.object = file.data
		} else if(file.data) try {
			file.object = JSON.parse(file.data)
		} catch(err) {
			file.error  = err
			file.object = file.data.split(/\r?\n/).filter(Boolean)
		} else {
			file.object = null
		}

		run.context[file.argument] = file.object
	}

	run.context.warn = warn
	run.context.run  = run
	run.context = vm.createContext(run.context)

	run.scripts.forEach(function(script) {
		try {
			run.context.$ = script.output = script.func.runInContext(run.context)
		} catch(e) {
			run.context.$ = script.output = e
		}
	})

	if(run.context.$ === undefined) {
		run.output = run.context._ || run.context.a
	} else {
		run.output = run.context.$
	}

	if(opt.dump) {
		run.result = run.scripts.map(function(s) { return s.source }).join('\n')
	} else if(opt.format) {
		run.result = format(run.output)
	} else if(opt.string || opt.write) {
		run.result = JSON.stringify(run.output)
	} else if(opt.unwrap && 'string' === typeof run.output) {
		run.result = run.output
	} else if(opt.unwrap && '[object Array]' === Object.prototype.toString.call(run.output)) {
		run.result = run.output.join('\n')
	} else {
		run.result = util.inspect(run.output, {
			colors : opt.colors,
			depth  : opt.depth
		})
	}
	if(!opt.noeofnl) run.result += '\n'

	if(opt.write) {
		var file = run.objects[1]
		fs.writeFileSync(file.name, run.result)
	} else {
		process.stdout.write(run.result)
	}
}

function format(object, tab, size, level, field, drop) {
	level = level |0
	tab   = tab  || '\t'
	size  = size || 100
	drop  = drop || []

	var indent = Array(level +1).join(tab || '\t')
	,   string

	if(object && typeof object === 'object') {
		if(typeof Node !== 'undefined' && object instanceof Node) {
			return null
		}
		if(drop.indexOf(object) !== -1) {
			return null
		}
		drop.push(object)

		try {
			var split = JSON.stringify(object).length > size

		} catch(e) { return null }


		var fields = []
		,   joint = split ? ',\n': ', '
		,   lnext = split ? level +1 : 0
		,   brackets

		if(object instanceof Array) {
			brackets = '[]'
			for(var i = 0; i < object.length; i++) {
				var item = format(object[i], tab, size, lnext, null, drop)
				fields.push(item)
			}

		} else {
			brackets = '{}'
			for(var name in object) {
				var item = format(object[name], tab, size, lnext, name, drop)
				if(item) fields.push(item)
			}
		}

		if(split) {
			string = brackets[0] +'\n'+ fields.join(joint) +'\n'+ indent + brackets[1]

		} else {
			string = brackets[0] + fields.join(joint) + brackets[1]
		}

	} else switch(typeof object) {

		case 'object':
		case 'boolean':
		case 'number':
			string = object
		break

		case 'string':
			string = JSON.stringify(object)
		break

		default:
		case 'function':
		case 'undefined':
			return null
	}

	return indent +(field ? JSON.stringify(field) +': ' : '')+ string
}

// vim:set ft=javascript:
